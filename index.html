<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
		<title>Tresoar viewer</title>
		<link rel="stylesheet" href="assets/css/bootstrap.min.css">
		<link rel="stylesheet" href="assets/css/ol.css">
		<link rel="stylesheet" href="assets/css/viewer.css">
		<script src="assets/js/proj4.js" type="text/javascript"></script>
		<script src="assets/js/ol-debug.js"></script>
		<script src="assets/js/jquery-2.2.0.min.js"></script>
		<script src="assets/js/bootstrap.min.js"></script>
		<script src="assets/js/transparency.min.js"></script>
		<script src="assets/js/jquery-sortable.min.js"></script>
	</head>
	<body>
		<div id="map" class="map"></div>

		<div id="feature-popup" class="popover right" role="tooltip">
			<div class="arrow"></div>
			<button type="button" class="close" aria-label="Close">
			  <span aria-hidden="true">&times;</span>
			</button>
			<h3 class="popover-title"></h3>
			<div class="popover-content">
				<table>
					<tbody class="feature-property-table">
						<tr>
							<th class="key"></th>
							<td class="value"></td>
						</tr>
					</tbody>
				</table>
			</div>
		</div>

		<div id="layers">
			<ul id="active-layers" class="layers list-group">
				<li class="layer list-group-item">
					<button type="button" class="remove-layer-button">Verberg</button>
					<span class="layer-name"></span>
					<input type="range" name="opacity" min="0" max="100" value="100">
				</li>
			</ul>

			<input type="search" id="layer-filter" placeholder="Zoek lagen…">
			
			<div id="available-layers" class="layers list-group">
				<button type="button" class="layer add-layer-button list-group-item">
					<span class="glyphicon glyphicon-plus-sign"></span>
					<span class="layer-name"></span>
				</button>
			</ul>
		</div>

		<script>
			"use strict"

			// Helper for jQuery.ajax and co. to easily use proxy server to go around CSRP
			$.ajaxPrefilter(function(options) {
				if (options.crossdomain) {
					options.url = 'http://mirror.ikhoefgeen.nl/tresoar-proxy.php?url=' + encodeURIComponent(options.url);
					options.crossdomain = false;
				}
			});

			proj4.defs("EPSG:28992", "+proj=sterea +lat_0=52.15616055555555 +lon_0=5.38763888888889 +k=0.9999079 +x_0=155000 +y_0=463000  +ellps=bessel  +towgs84=565.040,49.910,465.840,-0.40939,0.35971,-1.86849,4.0772 +units=m +no_defs");
		
			var EPSG28992 = new ol.proj.Projection({
				code: 'EPSG:28992'
			});
			
			ol.proj.addProjection(EPSG28992);
			
			var projection = EPSG28992;
			var projectionExtent = [-285401.92,22598.08,595401.9199999999,903401.9199999999];
			var size = ol.extent.getWidth(projectionExtent) / 256;
			var resolutions = [3440.64, 1720.32, 860.16, 430.08, 215.04, 107.52, 53.76, 26.88, 13.44, 6.72, 3.36, 1.68, 0.84, 0.42]
			
			// generate resolutions and matrixIds arrays for this WMTS
			var matrixIds = new Array(resolutions.length);
			for (var z = 0; z < matrixIds.length; ++z) {
				matrixIds[z] = 'EPSG:28992:' + z;
			}

			//FIXME this is ugly 
			//generate resolutions and matrixIds for luchtfoto
			var matrixIds2 = new Array(resolutions.length);
			for (var i = 0; i <= 13; ++i) {
				matrixIds2[i] = (i < 10 ? "0" : "") + i;
			}


			// FIXME it would be more awesome if we could retrieve this list (excl the base layers)
			// from Geoserver directly (through GetCapabilities?)
			
			// Could we then also access the extents of each layer? Then we can filter the list by
			// intersecting those with the current view extents.
			var layers = {
				brt: new ol.layer.Tile({
					id: 'brt',
					name: 'Achtergrondkaart BRT',
					extent: projectionExtent,
					source: new ol.source.WMTS({
						url: 'http://geodata.nationaalgeoregister.nl/tiles/service/wmts/brtachtergrondkaart',
						layer: 'brtachtergrondkaart',
						matrixSet: 'EPSG:28992',
						format: 'image/png',
						attributions: [new ol.Attribution({
						html: 'Kaartgegevens: © <a href="http://www.cbs.nl">CBS</a>, <a href="http://www.kadaster.nl">Kadaster</a>, <a href="http://openstreetmap.org">OpenStreetMap Bijdragers</a><span class="printhide"> (<a href="http://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>)' +
						' Kaartviewer: <a href="http://rug.nl/geo">Geodienst RUG</a>'
						})],
						projection: projection,
						tileGrid: new ol.tilegrid.WMTS({
							origin: ol.extent.getTopLeft(projectionExtent),
							resolutions: resolutions,
							matrixIds: matrixIds
						})
					})
				}),

				lufo: new ol.layer.Tile({
					id: 'lufo',
					name: 'Achtergrondkaart Luchtfoto\'s',
					extent: projectionExtent,
					source: new ol.source.WMTS({
						url: 'http://geodata1.nationaalgeoregister.nl/luchtfoto/wmts',
						service: 'WMTS',
						version: "1.0.0",
						layer: 'luchtfoto',
						matrixSet: 'nltilingschema',
						format: 'image/jpeg',
						style: '',
						attributions: [new ol.Attribution({
						html: 'Luchtfoto: <a href="https://www.pdok.nl/nl/copyright/luchtfotos/" target="_blank">© PDOK CC-BY-NC</a>'+
						' Kaartviewer: <a href="http://rug.nl/geo">Geodienst RUG</a>'
						})],
						projection: projection,
						visibility: true,
						zoomOffset: 2,
						tileGrid: new ol.tilegrid.WMTS({
							origin: ol.extent.getTopLeft(projectionExtent),
							resolutions: resolutions,
							matrixIds: matrixIds2
						})
					})
				})

				/*
				extents: {
					name: 'Geoserver example',
					layer: new ol.layer.Tile({
						source: new ol.source.WMTS({
							url: 'http://geoserver.ikhoefgeen.nl/geoserver/gwc/service/wmts',
							layer: 'geodienst:extents',
							matrixSet: 'EPSG:28992',
							format: 'image/png',
							projection: projection,
							tileGrid: new ol.tilegrid.WMTS({
								origin: ol.extent.getTopLeft(projectionExtent),
								resolutions: resolutions,
								matrixIds: matrixIds
							})
						})
					})
				}
				*/
			};

			var map = new ol.Map({
				maxExtent: projectionExtent,
				layers: [],
				target: $('#map').get(0),
				maxResolution: 860.16,
				numZoomLevels: 12,
				units: 'm',
				theme: null,
				displayProjection: EPSG28992,
				view: new ol.View({
					projection: EPSG28992,
					center: ol.extent.getCenter(projectionExtent), // FIXME center on Fryslân!
					maxZoom: 19,
					minZoom: 8,
					zoom: 9
				})
			});

			function updateLayerZOrder() {
				var $layers = $('#active-layers').find('.layer');
				$layers
					.map(function() { return $(this).prop('data-layer-id'); })
					.each(function(i) { layers[this].setZIndex($layers.length - 1 - i); });
			}

			// Render the list of layers (using Transparency.js templating)
			function updateLayerList() {
				var activeLayerIds = map.getLayers().getArray().map(function(layer) {
					return layer.get('id'); });

				$('#active-layers').render(
					Array.prototype.slice.call(map.getLayers().getArray())
						.map(function(layer) {
							return {
								layer: {
									'id': layer.get('id'),
									'z-index': layer.getZIndex(),
									'layer-name': layer.get('name'),
									'opacity': layer.getOpacity() * 100
								}
							};
						})
						.sort(function(a, b) {
							return b['layer']['z-index'] - a['layer']['z-index'];
						}),
					{ // directives on how to render this stuff
						'layer': {
							'data-layer-id': function() {
								return this.layer.id;
							}
						}
					}
				);

				// Layers are rendered with the top-most in the list as the top-most in the view
				// (Transpacenry template rendering does not take order into account, probably
				// because sortable() screws up some internal model of the siblings.)
				$('#active-layers .layer')
					.sort(function(a, b) {
						return layers[$(b).attr('data-layer-id')].getZIndex()
							 - layers[$(a).attr('data-layer-id')].getZIndex(); 
					})
					.detach()
					.appendTo('#active-layers');
						

				$('#available-layers').render(
					// render all layers that are not already on the map
					$.map(layers, function(layer) {
						// If the layer is already on the map, hide it in the available list
						if (activeLayerIds.indexOf(layer.get('id')) >= 0)
							return null;

						return {
							layer: {
								'id': layer.get('id'),
								'layer-name': layer.get('name')
							}
						};
					}).sort(function(a, b) { // sort layers alphabetically
						return a['layer']['layer-name'].localeCompare(b['layer']['layer-name']);
					}),
					{ // directives on how to render this stuff
						'layer': {
							'data-layer-id': function() {
								return this.layer.id;
							}
						}
					}
				);
			}

			var adjustment;

			// Using https://johnny.github.io/jquery-sortable/ to make the active layer list orderable
			$('#active-layers').sortable({
				group: 'layers',

				// set $item relative to cursor position
				onDragStart: function ($item, container, _super) {
					var offset = $item.offset(),
						pointer = container.rootGroup.pointer;

					adjustment = {
						left: pointer.left - offset.left,
						top: pointer.top - offset.top
					};

					_super($item, container);
				},
				onDrag: function ($item, position) {
					$item.css({
						left: position.left - adjustment.left,
						top: position.top - adjustment.top
					});
				},
				onDrop: function($item, container, _super) {
					updateLayerZOrder();
					_super($item, container);
				},
				serialize: function (parent, children, isContainer) {
					return isContainer ? children.join() : parent.attr('data-layer-id');
				},
			});

			// Also enable dragging layers from the available list to the enabled list
			$('#available-layers').sortable({
				group: 'layers',
				drop: false,
				nested: false,
				handle: '.list-group-item',
				containerSelector: '.list-group',
				itemSelector: '.list-group-item',
				onMouseDown: function ($item, _super, event) {
					event.preventDefault()
					return true;
				}
			});

			// Update the layer list now
			updateLayerList();

			// Update the layer list every time a layer is enabled or disabled
			map.getLayers().on('add', updateLayerList);
			
			map.getLayers().on('remove', updateLayerList);

			var featureOverlay = new ol.layer.Vector({
				map: map,
				source: new ol.source.Vector({
					features: new ol.Collection(),
					useSpatialIndex: false
				}),
				style: new ol.style.Style({
					stroke: new ol.style.Stroke({
						color: 'red',
						width: 2
					})
				}),
				updateWhileAnimating: true,
				updateWhileInteracting: true
			});

			// Make stuff interactive

			$('#layers').on('click', '.add-layer-button', function(e) {
				var layerId = $(this).attr('data-layer-id');
				var layer = layers[layerId];
				// Remove the bounding box overlay if that is still shown
				if (layer.get('bbox'))
					featureOverlay.getSource().removeFeature(layer.get('bbox'));

				// Move the layer to the top
				layer.setZIndex(map.getLayers().getArray().length);
				
				// Add the layer to the map
				map.addLayer(layer);
			});

			$('#layers').on('click', '.remove-layer-button', function(e) {
				var layerId = $(this).closest('.layer').attr('data-layer-id');
				var layer = layers[layerId];
				if (layer.get('bbox'))
					featureOverlay.getSource().removeFeature(layer.get('bbox'));
				map.removeLayer(layer);
			});

			$('#layers').on('change', '.layer input[name=opacity]', function(e) {
				var layerId = $(this).closest('.layer').attr('data-layer-id');
				layers[layerId].setOpacity(this.value / 100);
			});

			$('#layers').on('mouseover', '.layer', function(e) {
				var layerId = $(this).attr('data-layer-id');
				var layer = layers[layerId];
				if (layer.get('bbox')) {
					featureOverlay.getSource().addFeature(layer.get('bbox'));
				}
			});

			// FIXME the outline will not disappear when the layer suddenly is removed from
			// the list e.g. when the layer is added to the active list.
			$('#layers').on('mouseout', '.layer', function(e) {
				var layerId = $(this).attr('data-layer-id');
				var layer = layers[layerId];
				if (layer.get('bbox') !== undefined && featureOverlay.getSource().getFeatures().indexOf(layer.get('bbox')) !== -1) {
					featureOverlay.getSource().removeFeature(layer.get('bbox'));
				}
			});

			$('#layer-filter').on('search', function() {
				var query = $(this).val().toLowerCase();
				$('#available-layers .layer').each(function() {
					$(this).toggle(query == "" || $(this).find('.layer-name').text().toLowerCase().indexOf(query) !== -1);
				});
			});

			// Feature popup
			var popup = new ol.Overlay({
				element: $('#feature-popup').detach().get(0),
				positioning: 'center-left',
				stopEvent: false
			});

			map.addOverlay(popup);

			$(popup.getElement()).find('.close').on('click', function() {
				$(popup.getElement()).hide();
			});

			map.on('click', function(evt) {
				var feature = map.forEachFeatureAtPixel(evt.pixel, function(feature, layer) { return feature; });
				
				if (feature) {
					var geometry = feature.getGeometry();
					var coord = geometry.getCoordinates();
					popup.setPosition(evt.coordinate);
					$(popup.getElement()).show().render({
						'popover-title': feature.get('NAAM'),
						'feature-property-table':
							$.map(feature.getProperties(), function(v, k) {
								return { 'key': k, 'value': v };
							}).filter(function(pair) {
								return !/^(OBJECTID$|GLOBALID$|SHAPE$|SHAPE_)/.test(pair.key);
							})
					});
				}
			});

			map.on('pointermove', function(e) {
				var pixel = map.getEventPixel(e.originalEvent);
				var hit = map.hasFeatureAtPixel(pixel);
				map.getTarget().style.cursor = hit ? 'pointer' : '';
			});

			var geolocation = new ol.Geolocation({
				// take the projection to use from the map's view
				projection: map.getView().getProjection()
			});
			
			// listen to changes in position
			geolocation.on('change', function(evt) {
				window.console.log(geolocation.getPosition());
			});

			// Start with a brt achtergrond kaart as layer
			map.addLayer(layers.brt);

			$.ajax('http://geoportaal.fryslan.nl/arcgis/services/ProvinciaalGeoRegister/PGR_features/GeoDataServer/WFSServer', {
				type: 'GET',
				crossdomain: true,
				dataType: 'xml',
				data: {
					service: 'WFS',
					version: '1.0.0',
					request: 'GetCapabilities'
				}
			}).done(function(data) {
				var features = $(data).find('FeatureTypeList').map(function() {
					return $(this).find('FeatureType').map(function() {
						var $feature = $(this),
							$bbox = $feature.find('LatLongBoundingBox');

						var bbox = $bbox.length ? new ol.Feature({
							typename: $feature.find('Name').text(),
							geometry: new ol.geom.Polygon([[
								[$bbox.attr('minx'), $bbox.attr('miny')].map(parseFloat),
								[$bbox.attr('maxx'), $bbox.attr('miny')].map(parseFloat),
								[$bbox.attr('maxx'), $bbox.attr('maxy')].map(parseFloat),
								[$bbox.attr('minx'), $bbox.attr('maxy')].map(parseFloat)
							]], 'XY')
						}) : null;

						// Ugly side-effect implementation
						layers[$feature.find('Title').text()] = new ol.layer.Vector({
							id: $feature.find('Title').text(),
							name: $feature.find('Title').text(),
							bbox: bbox,
							source: new ol.source.Vector({
								loader: function(extent, resolution, projection) {
									$.ajax('http://geoportaal.fryslan.nl/arcgis/services/ProvinciaalGeoRegister/PGR_features/GeoDataServer/WFSServer', {
										type: 'GET',
										crossdomain: true,
										data: {
											service: 'WFS',
											version: '1.0.0',
											request: 'GetFeature',
											typename: $feature.find('Name').text(),
											srsname: 'EPSG:28992', // todo: get this info from $feature?
											bbox: extent.join(',')
										}
									}).done(function(data) {
										var format = new ol.format.GML2();
										this.addFeatures(format.readFeatures(data));
									}.bind(this));
								},
								strategy: ol.loadingstrategy.tile(ol.tilegrid.createXYZ({
									maxZoom: 19
								})),
								projection: 'EPSG:28992'
							}),
							style: new ol.style.Style({
								stroke: new ol.style.Stroke({
									color: 'green',
									width: 2
								})
							})
						});

						return bbox;
					}).get();
				}).get();

				// Add a debug map that contains all the extents of the just fetched WFS
				layers['FryslanWFS'] = new ol.layer.Vector({
					id: 'FryslanWFS',
					name: '#Fryslan WFS extents',
					source: new ol.source.Vector({
						features: features,
						strategy: ol.loadingstrategy.tile(ol.tilegrid.createXYZ({
							maxZoom: 19
						})),
						projection: 'EPSG:28992',
						attributions: [new ol.Attribution({
							html: 'Feature bboxes'
						})],
					}),
					style: new ol.style.Style({
						stroke: new ol.style.Stroke({
							color: 'green',
							width: 2
						}),
						fill: new ol.style.Fill({
							color: [0, 0, 255, 0.6]
						})
					})
				});

				updateLayerList();
			});

		</script>
	</body>
</html>